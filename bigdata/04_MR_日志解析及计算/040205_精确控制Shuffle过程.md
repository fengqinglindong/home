## Shuffle过程

	* Map端
		- partition将相同的数据分到同一个Reduce（什么是相同的数据？对key值进行排序的，指定不同的输出key  
		  值，表示不同的数据）
		- sort对输出的数据进行排序（按照什么规则排序？在key中设置一个方法，进行排序。）
		- spill将缓冲区中的数据溢写到文件中
		- merge将溢写文件排序合并成一个文件
		
	* Reduce端
		- copy将map中属于自己的数据拉取到本地
		- merge sort将数据进行排序合并（按照什么规则排序）
		- 相同key值对应的value放进一个迭代器中（怎么定义相同key值）

	总结：
		1. 哪些数据可以放到同一Reduce上。
		2. 对数据排序按照什么规则进行排序。
		3. 哪些数据在Reduce端会被放到同一个迭代器中。
		4. MR提供了三个API来帮助我控制整个Shuffle过程。

## 控制Shuffle的API


	1. setPartitionClass()
		* 设置控制partition的类，来编写自己的算法，将数据划分到不同的partition中，默认对输出的key值使  
		  用HashPartition。对于自定义的一般是在HashPartition中加入直接的业务代码。

	2. setSortComparatorClass()
		* 设置控制数据排序的类，如果不设置，默认使用输出的Key值的比较方法排序。

	3. setGroupingComparatorClass()
		* 设置控制Reduce端的哪些key值对应的value放在一个迭代器中。

## 二次排序

	对第一列数据进行排序，在第一列数据有序后，再对第而列数据进行排序。这就是二次排序。

	在MR程序中，对于大量数据如何进行二次排序？

		* 在MR中进行排序的数据都是key，把两行中的数据都作为key值来使用
		* 哪些key值需要发送到同一个Reduce端，对于第一列相同的key值放到同一个Reduce端。这样才能保证排  
		  序后的结果是全局有序的。可以为第一列数据单独编写partition类，这些数据是按照什么样的规则进行  
		  排序的？首先对第一列数据进行排序，在第一列数据有序的情况下，对第二列数据进行排序。可以将这个  
		  规则直接写入到这个key值的Comparator方法中。
		* 如果这个key值的第一列value值元素，需要放到一个集合中，这时，我们需要设置一个GroupingComparator，
		  它会判断第一列数据是否相同，如图第一列数据相同，就会将第一列的value值放到同一个迭代器中。

	
	二次排序的过程：
		1. 构造符合的Writable类型，包含两个字段，一个字段来控制着条数据会被分配到哪个Reduce上。两个字段合在一起用来排序，作为Map的输出Key。
		2. 设置自定义的partitioner，对复合类型的第一个字段进行分区。也就是用来指定哪些数据会被分配到
		   同一个Reduce上。
		3. 设置排序类，或者在自定的partitioner里设置Comparator方法。当复合类型的第一个字段相同时，
		   比较第二个字段。否则使用第一个字段的比较结果。
		4. 设置分组类，按照第一个字段进行分组。将对应的value值放在同一个迭代器中。

## 访问路径

	需求：用户访问行为是以session为单位的。每一条访问日志都记录从这个session开始到当前页面的访问路径，存为一个List。

## 代码
		


	


