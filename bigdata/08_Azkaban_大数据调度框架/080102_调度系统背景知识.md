## 调度系统类别
- 资源调度系统（资源管理系统）
	- 与操作系统打交道，对操作系统资源进行抽象，比如内存、磁盘、CPU等，实现集群化，整合大量机器的资源来满足资源需要巨大的需求场景。资源抽象的基础上提供任务模型，为上层应用提供统一的资源管理和任务调度。为集群在利用率、资源统一管理和数据共享方面带来了好处。
	- 衡量资源调度系统的标志有三点：
		- 资源的抽象和隔离
		- 集群的规模
		- 稳定性
	- 资源管理系统有（yarn、mesos、omega、borg等）
- 作业调度系统
	- 偏上层应用，实现大数据系统的启动、执行和调度
	- 衡量标准
		- 能够支持哪些大数据组件
		- 能够支持哪些调度模型
		- 用户体验
		- 稳定性
	- 有（oozie、azkaban、chronos等）

## 任务调度系统的位置
![080201_azkaban_position](https://i.imgur.com/OQzzn8n.png)

最底层为节点机器，节点机器不一定要是物理机，可以是虚拟机。机器配置最好做到一致，操作系统一致，资源配置一致。  

底层之上为资源调度系统和分布式文件系统，对集群资源进行抽象管理，提供基于资源的抽象模型，并进行相应的调度管理，任务概念偏向底层，不是具体的大数据任务，可以类比为进程。这一层提供文件操作接口，任务创建、查看、终止接口，以及资源配额的操作接口。
  
在资源调度系统之上的是各类大数据组件，常见有hive、spark、pig、impala。各组件有独立的数据模型，和特定的使用场景。这些组件对外提供一些交互方案，比如SQL或者特定的API，然后根据接收到SQL或者代码解析成针对数据模型的逻辑执行计划，把对数据模型的访问翻译成对分布式文件的访问，把具体的逻辑执行计划翻译成资源调度系统的作业，提交到下层，最终得到结果。  

大数据组件之上是作业调度系统，会访问、封装各个底层的部署细节，提供统一的作业提交和部署方案，并且围绕这两个核心完善周边功能，提供使用效率。  
最上层为数据开发平台，用户可以直接访问。

## 作业调度系统用处 ##
- 提高数据工程师的开发效率
- 更好的利用/共享数据

## 作业调度系统分类 ##
- 定时分片类系统  
	- 场景定位  
任何任务都可以拆分为小任务，各个小任务可以并行运行，任务调度时间固定。存在时间轴总线，总线上存在多个挂载点，可以是每小时每天等等，用户可以根据需求将任务拆分为多个小任务，挂载到具体挂载点。这类系统目前有：TBSchedule、SchedulerX、Elastic-job、Saturn。  
	- 关注的目标是：  
不漏不重，负载均衡，弹性扩容，失效转移  
精确定时触发，强实时性和高可靠性
	- 业务影响  
对所调度的任务往往有代码入侵性要求  
对有些系统还要求常驻Daemon进程，用于协助通讯

- DAG工作流类系统
	- 场景定位
		- 所服务的往往是流程依赖比较复杂的场景
		- 可能涉及到成千上万个相互交叉依赖关联的作业
		- Oozie、Azkaban、chronos、Zeus,Lhotse

	- 关注目标
		- 丰富灵活的触发机制：时间、依赖，混合确定时触发，强实时性和高可靠性
		- 灵活作业变更管理，流程管控
		- 优先级管理，业务隔离，错误跟踪，异常报警
		- 系统和业务健康度监控，性能和问题诊断

## DAG基本元素 ##
DAG：是指有向无环图。  

- Activity（Job、Node）  
	- 执行类型  
		- MR/Hive/Spark/sqoop（具体某种大数据任务组件）
		- Script/command（程序类型）
	- 控制类型（负责DAG作业的流向，）
		- 条件节点、引用节点
	- 判断类型
		- 目录/table是否存在、任务是否完成
- WorkFlow（DAG、Flow、Task）
	- 由Job组成的有向无环图
	- 依赖关系确定走向
	- 拒绝循环依赖
- Schedule（trigger）
Schedule定义调度模式，也就是WorkFlow在什么情况下会被调度执行，Schedule的载体是flow。

一般来说调度模式有三种：

一种是周期性调度，单位可以是月周日时分秒，是最常见也是最广泛的调度；

第二种是cromtab类的调度，调度可以配置，比如定时上午九点下午五点各执行一次，这种方式也可以实现周期性调度，与周期性调度一样都是基于时间的调度模式；

第三种是条件触发，比如依赖的某个flow和job已经完成、某个table已经生成等等。

调度模式可以相互组合，既有周期性调度又有条件触发。

Schedule可以根据业务模式进行划分：是否是补数据（所谓补数据是调度的时间是已经过去的时间而不是未来的时间），补数据一般出现在基于时间的调度模式下。补数据的场景下，除了要保证flow正常调度执行之外，还需要做好流控，控制好并发和优先级，均衡系统负载，因为补数据可能补了过去很长一段时间的业务逻辑。

- 任务计划执行时间：schedule.exec.time，指的是Schedule逻辑上触发flow执行的时间，实际场景下任务计划执行时间和任务实际执行时间会有一定的误差，在非补数据的场景下应该尽量减少误差。

- 调度任务实例：任务计划执行时间 + Flow，表示flow在每次任务调度下的执行，可类比于数据 + 代码 = 进程

## 基本架构
![](https://i.imgur.com/2audoDh.png)

- Meta Model
	- 元数据管理模块，负责元数据的持久化和读取，一般而言Flow，Schedule都是元数据
- Storage Model
	- 存储模块，存储Flow运行所需要的资源文件，比如jar包、配置文件等等，实例执行完成的日志。
- Execute Model
	- 执行模块，执行具体的job，调用具体的大数据组件，提交任务，并且将执行情况保存在日志中回传给存储系统。
- Manager
	- 管理模块，调度系统大脑，负责读取元数据，构建调度逻辑，生成调度实例，根据既定的分发策略负载均衡，将调度任务分发给执行模块，同时接受执行模块的反馈，更新执行模块的状态。



